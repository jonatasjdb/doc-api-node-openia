{
  "version": 3,
  "sources": ["../../src/helpers/set-value-at-path.ts"],
  "sourcesContent": ["import { preventPollution } from '@scalar/helpers/object/prevent-pollution'\n\nimport { getSegmentsFromPath } from '@/helpers/get-segments-from-path'\n\n/**\n * Sets a value at a specified path in an object, creating intermediate objects/arrays as needed.\n * This function traverses the object structure and creates any missing intermediate objects\n * or arrays based on the path segments. If the next segment is a numeric string, it creates\n * an array instead of an object.\n *\n * \u26A0\uFE0F Warning: Be careful with object keys that look like numbers (e.g. \"123\") as this function\n * will interpret them as array indices and create arrays instead of objects. If you need to\n * use numeric-looking keys, consider prefixing them with a non-numeric character.\n *\n * @param obj - The target object to set the value in\n * @param path - The JSON pointer path where the value should be set\n * @param value - The value to set at the specified path\n * @throws {Error} If attempting to set a value at the root path ('')\n *\n * @example\n * const obj = {}\n * setValueAtPath(obj, '/foo/bar/0', 'value')\n * // Result:\n * // {\n * //   foo: {\n * //     bar: ['value']\n * //   }\n * // }\n *\n * @example\n * const obj = { existing: { path: 'old' } }\n * setValueAtPath(obj, '/existing/path', 'new')\n * // Result:\n * // {\n * //   existing: {\n * //     path: 'new'\n * //   }\n * // }\n *\n * @example\n * // \u26A0\uFE0F Warning: This will create an array instead of an object with key \"123\"\n * setValueAtPath(obj, '/foo/123/bar', 'value')\n * // Result:\n * // {\n * //   foo: [\n * //     undefined,\n * //     undefined,\n * //     undefined,\n * //     { bar: 'value' }\n * //   ]\n * // }\n */\nexport function setValueAtPath(obj: any, path: string, value: any): void {\n  if (path === '') {\n    throw new Error(\"Cannot set value at root ('') pointer\")\n  }\n\n  const parts = getSegmentsFromPath(path)\n\n  // Prevent prototype pollution\n  parts.forEach((part) => preventPollution(part))\n\n  let current = obj\n\n  for (let i = 0; i < parts.length; i++) {\n    const key = parts[i]\n    const isLast = i === parts.length - 1\n\n    const nextKey = parts[i + 1]\n    const shouldBeArray = /^\\d+$/.test(nextKey ?? '')\n\n    if (isLast) {\n      current[key] = value\n    } else {\n      if (!(key in current) || typeof current[key] !== 'object') {\n        current[key] = shouldBeArray ? [] : {}\n      }\n      current = current[key]\n    }\n  }\n}\n"],
  "mappings": "AAAA,SAAS,wBAAwB;AAEjC,SAAS,2BAA2B;AAkD7B,SAAS,eAAe,KAAU,MAAc,OAAkB;AACvE,MAAI,SAAS,IAAI;AACf,UAAM,IAAI,MAAM,uCAAuC;AAAA,EACzD;AAEA,QAAM,QAAQ,oBAAoB,IAAI;AAGtC,QAAM,QAAQ,CAAC,SAAS,iBAAiB,IAAI,CAAC;AAE9C,MAAI,UAAU;AAEd,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,UAAM,MAAM,MAAM,CAAC;AACnB,UAAM,SAAS,MAAM,MAAM,SAAS;AAEpC,UAAM,UAAU,MAAM,IAAI,CAAC;AAC3B,UAAM,gBAAgB,QAAQ,KAAK,WAAW,EAAE;AAEhD,QAAI,QAAQ;AACV,cAAQ,GAAG,IAAI;AAAA,IACjB,OAAO;AACL,UAAI,EAAE,OAAO,YAAY,OAAO,QAAQ,GAAG,MAAM,UAAU;AACzD,gBAAQ,GAAG,IAAI,gBAAgB,CAAC,IAAI,CAAC;AAAA,MACvC;AACA,gBAAU,QAAQ,GAAG;AAAA,IACvB;AAAA,EACF;AACF;",
  "names": []
}
