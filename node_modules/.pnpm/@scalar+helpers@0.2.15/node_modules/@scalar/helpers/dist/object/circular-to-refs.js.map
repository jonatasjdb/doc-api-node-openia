{
  "version": 3,
  "sources": ["../../src/object/circular-to-refs.ts"],
  "sourcesContent": ["/**\n * OpenAPI component types that can contain circular references.\n * Each type maps to a section in `#/components/{type}`.\n */\nconst COMPONENT_PREFIXES = {\n  schemas: 'CircularSchema',\n  responses: 'CircularResponse',\n  parameters: 'CircularParameter',\n  examples: 'CircularExample',\n  requestBodies: 'CircularRequestBody',\n  headers: 'CircularHeader',\n  securitySchemes: 'CircularSecurityScheme',\n  links: 'CircularLink',\n  callbacks: 'CircularCallback',\n  pathItems: 'CircularPathItem',\n} as const\n\ntype ComponentType = keyof typeof COMPONENT_PREFIXES\nconst COMPONENT_TYPES = Object.keys(COMPONENT_PREFIXES) as ComponentType[]\n\n/**\n * Lookup table for OpenAPI keys that change the component context.\n * Using an object lookup is faster than a switch statement for many keys.\n */\nconst KEY_TO_CONTEXT: Readonly<Record<string, ComponentType>> = {\n  responses: 'responses',\n  parameters: 'parameters',\n  requestBody: 'requestBodies',\n  headers: 'headers',\n  examples: 'examples',\n  links: 'links',\n  callbacks: 'callbacks',\n  securitySchemes: 'securitySchemes',\n  schema: 'schemas',\n  items: 'schemas',\n  additionalProperties: 'schemas',\n  allOf: 'schemas',\n  oneOf: 'schemas',\n  anyOf: 'schemas',\n  not: 'schemas',\n  properties: 'schemas',\n  patternProperties: 'schemas',\n  get: 'pathItems',\n  put: 'pathItems',\n  post: 'pathItems',\n  delete: 'pathItems',\n  options: 'pathItems',\n  head: 'pathItems',\n  patch: 'pathItems',\n  trace: 'pathItems',\n}\n\n/**\n * These container objects must remain maps in OpenAPI and cannot be replaced by a Reference Object.\n * When a cycle points to one of these containers, we lift the ref to a legal parent object.\n */\nconst NON_REFERENCE_CONTAINER_KEYS = new Set(['properties', 'patternProperties', 'responses'])\n\n/**\n * Determines the component context for a given OpenAPI key.\n * Returns the appropriate ComponentType or null to inherit parent context.\n */\nconst getContextForKey = (key: string): ComponentType | null => {\n  // Fast path: direct lookup for known keys\n  const context = KEY_TO_CONTEXT[key]\n  if (context !== undefined) {\n    return context\n  }\n\n  // Callback path expressions (keys containing '{$') or path templates have pathItem values\n  if (key.includes('{$') || key.charCodeAt(0) === 47 /* '/' */) {\n    return 'pathItems'\n  }\n\n  // No context change \u2014 inherit from parent\n  return null\n}\n\n/** Metadata about a circular object: its component type and generated name */\ntype CircularMeta = {\n  readonly type: ComponentType\n  readonly name: string\n}\n\ntype NonReferenceContainerInfo = {\n  readonly key: 'properties' | 'patternProperties' | 'responses'\n  readonly owner: object\n}\n\n/**\n * Detects and breaks circular JavaScript object references in an OpenAPI document tree.\n *\n * The legacy API client (via openapi-parser's dereference) resolved all $refs inline:\n * it deleted the $ref key and copied every property from the resolved target directly\n * onto the object. For self-referencing or mutually-referencing schemas this created\n * circular JS object graphs that cannot be serialized to JSON or validated by TypeBox.\n *\n * This function walks the object tree depth-first, detects cycles via reference identity,\n * extracts each circular component into the appropriate components section (schemas,\n * responses, parameters, etc.) with a generated name, and replaces ALL occurrences\n * (both first and back-references) with **only** `$ref` and any extra properties\n * (no extra schema properties) so that TypeBox's Value.Cast picks the reference branch\n * of the schemaOrReference union.\n *\n * Returns a new (deep-cloned) document with all cycles replaced. When no circular\n * references exist, the output is structurally identical to the input.\n *\n * @param document - The OpenAPI document to process\n * @param extraProps - Extra properties to add as siblings to the $ref (e.g., '$ref-value')\n * @returns A new document with circular references replaced by $ref pointers\n */\nexport const circularToRefs = (\n  document: Record<string, unknown>,\n  extraProps: Record<string, unknown> = {},\n): Record<string, unknown> => {\n  /**\n   * Phase 1 structures:\n   * - circularMeta: Maps circular objects to their component type and generated name\n   * - objectContext: Records the context when an object is first encountered\n   * - existingComponentNames: Maps objects to their existing component names (if in components section)\n   * - counters: Tracks unique naming counters per component type\n   */\n  const circularMeta = new Map<object, CircularMeta>()\n  const objectContext = new Map<object, ComponentType>()\n  const existingComponentNames = new Map<object, { type: ComponentType; name: string }>()\n  const nonReferenceContainers = new WeakSet<object>()\n  const nonReferenceContainerInfo = new WeakMap<object, NonReferenceContainerInfo>()\n  const counters: Record<ComponentType, number> = {\n    schemas: 0,\n    responses: 0,\n    parameters: 0,\n    examples: 0,\n    requestBodies: 0,\n    headers: 0,\n    securitySchemes: 0,\n    links: 0,\n    callbacks: 0,\n    pathItems: 0,\n  }\n\n  /**\n   * Pre-scan: Map existing components to their names.\n   * This allows us to reference existing schemas instead of creating duplicates.\n   */\n  const scanExistingComponents = (doc: Record<string, unknown>): void => {\n    const components = doc.components as Record<string, unknown> | undefined\n    if (!components) {\n      return\n    }\n\n    for (const componentType of COMPONENT_TYPES) {\n      const section = components[componentType] as Record<string, unknown> | undefined\n      if (!section) {\n        continue\n      }\n\n      for (const [name, value] of Object.entries(section)) {\n        if (value !== null && typeof value === 'object') {\n          existingComponentNames.set(value as object, { type: componentType, name })\n        }\n      }\n    }\n  }\n\n  /**\n   * Phase 1: Identify all circular objects in the tree.\n   *\n   * We traverse depth-first, tracking ancestors in the current path. When we\n   * encounter an object already in the ancestor set, we've found a cycle.\n   * We record the circular object with its context and a generated name.\n   *\n   * @param value - Current value being traversed\n   * @param ancestors - Set of objects in the current traversal path\n   * @param context - Current OpenAPI component context\n   */\n  const identifyCircularObjects = (value: unknown, ancestors: Set<object>, context: ComponentType): void => {\n    // Primitives and null cannot be circular\n    if (value === null || typeof value !== 'object') {\n      return\n    }\n\n    const obj = value as object\n\n    // Cycle detected: this object is already in our ancestor chain\n    if (ancestors.has(obj)) {\n      // Keep container maps as maps; we will lift refs on their entries during cloning.\n      if (nonReferenceContainers.has(obj)) {\n        return\n      }\n\n      // Only register once \u2014 use existing name if available, otherwise generate new one\n      if (!circularMeta.has(obj)) {\n        const existing = existingComponentNames.get(obj)\n        if (existing) {\n          // Use the existing component name\n          circularMeta.set(obj, existing)\n        } else {\n          // Generate a new name\n          const componentType = objectContext.get(obj) ?? context\n          const count = ++counters[componentType]\n          circularMeta.set(obj, {\n            type: componentType,\n            name: `${COMPONENT_PREFIXES[componentType]}${count}`,\n          })\n        }\n      }\n      return\n    }\n\n    // Record context on first encounter for accurate categorization\n    if (!objectContext.has(obj)) {\n      objectContext.set(obj, context)\n    }\n\n    // Add to ancestor chain and recurse\n    ancestors.add(obj)\n\n    if (Array.isArray(obj)) {\n      for (const item of obj) {\n        identifyCircularObjects(item, ancestors, context)\n      }\n    } else {\n      // Objects: check each property, updating context as needed\n      const record = obj as Record<string, unknown>\n      for (const key of Object.keys(record)) {\n        const child = record[key]\n        if (\n          NON_REFERENCE_CONTAINER_KEYS.has(key) &&\n          child !== null &&\n          typeof child === 'object' &&\n          !Array.isArray(child)\n        ) {\n          nonReferenceContainers.add(child as object)\n          nonReferenceContainerInfo.set(child as object, {\n            key: key as NonReferenceContainerInfo['key'],\n            owner: obj,\n          })\n        }\n\n        const newContext = getContextForKey(key) ?? context\n        identifyCircularObjects(child, ancestors, newContext)\n      }\n    }\n\n    // Remove from ancestor chain when backtracking\n    ancestors.delete(obj)\n  }\n\n  /** Stores processed (cycle-free) definitions by type and name */\n  const extractedComponents = new Map<ComponentType, Map<string, unknown>>()\n\n  /** Precompute whether we have extra props to avoid repeated Object.keys calls */\n  const hasExtraProps = Object.keys(extraProps).length > 0\n\n  /** Creates a $ref object pointing to the extracted component */\n  const createRefObject = (meta: CircularMeta): Record<string, unknown> => {\n    const ref = { $ref: `#/components/${meta.type}/${meta.name}` }\n    return hasExtraProps ? { ...ref, ...extraProps } : ref\n  }\n\n  /** Gets or creates the target section for extracted components. */\n  const getOrCreateExtractedSection = (type: ComponentType): Map<string, unknown> => {\n    const existing = extractedComponents.get(type)\n    if (existing !== undefined) {\n      return existing\n    }\n\n    const section = new Map<string, unknown>()\n    extractedComponents.set(type, section)\n    return section\n  }\n\n  /** Ensures an object has component metadata so it can be referenced legally. */\n  const ensureMeta = (obj: object, fallbackType: ComponentType): CircularMeta => {\n    const existingMeta = circularMeta.get(obj)\n    if (existingMeta !== undefined) {\n      return existingMeta\n    }\n\n    const existingName = existingComponentNames.get(obj)\n    if (existingName !== undefined) {\n      circularMeta.set(obj, existingName)\n      return existingName\n    }\n\n    const count = ++counters[fallbackType]\n    const meta: CircularMeta = {\n      type: fallbackType,\n      name: `${COMPONENT_PREFIXES[fallbackType]}${count}`,\n    }\n    circularMeta.set(obj, meta)\n    return meta\n  }\n\n  /** Lifts illegal container self-cycles to a legal reference target. */\n  const createLiftedRefForContainer = (\n    container: object,\n    clonedContainer?: Record<string, unknown>,\n  ): Record<string, unknown> | undefined => {\n    const info = nonReferenceContainerInfo.get(container)\n    if (info === undefined) {\n      return undefined\n    }\n\n    if (info.key === 'properties' || info.key === 'patternProperties') {\n      const meta = ensureMeta(info.owner, 'schemas')\n      return createRefObject(meta)\n    }\n\n    // responses map values must be Response Object or Reference Object.\n    // Lift self-cycle to the first concrete response entry.\n    const responses = container as Record<string, unknown>\n    for (const [key, value] of Object.entries(responses)) {\n      if (value === null || typeof value !== 'object' || value === container) {\n        continue\n      }\n\n      const responseObject = value as object\n      const meta = ensureMeta(responseObject, 'responses')\n      if (!existingComponentNames.has(responseObject)) {\n        const section = getOrCreateExtractedSection(meta.type)\n        if (!section.has(meta.name)) {\n          const clonedValue = clonedContainer?.[key]\n          if (clonedValue !== undefined) {\n            section.set(meta.name, clonedValue)\n          }\n        }\n      }\n\n      return createRefObject(meta)\n    }\n\n    return undefined\n  }\n\n  const cloneNode = (obj: object, visited: Set<object>, context: ComponentType): unknown => {\n    return Array.isArray(obj) ? cloneArray(obj, visited, context) : cloneObject(obj, visited, context)\n  }\n\n  const cloneNodeWithVisitTracking = (obj: object, visited: Set<object>, context: ComponentType): unknown => {\n    // Keep visit bookkeeping in one place so all clone paths handle cycles consistently.\n    visited.add(obj)\n    const cloned = cloneNode(obj, visited, context)\n    visited.delete(obj)\n    return cloned\n  }\n\n  /**\n   * Phase 2: Create a deep clone with circular references replaced by $refs.\n   * For circular objects, we extract to components and return $ref.\n   * For non-circular objects, we simply deep clone.\n   */\n  const cloneWithRefs = (value: unknown, visited: Set<object>, context: ComponentType): unknown => {\n    if (value === null || typeof value !== 'object') {\n      return value\n    }\n\n    const obj = value as object\n    const meta = circularMeta.get(obj)\n\n    // If this is a circular object and we're already visiting it, return a $ref to break the cycle\n    if (meta !== undefined) {\n      if (visited.has(obj)) {\n        return createRefObject(meta)\n      }\n\n      const cloned = cloneNodeWithVisitTracking(obj, visited, context)\n      if (existingComponentNames.has(obj)) {\n        // Do not extract \u2014 it already exists in components.\n        // Just clone it in place and replace circular back-references with $ref.\n        return cloned\n      }\n\n      const section = getOrCreateExtractedSection(meta.type)\n      if (!section.has(meta.name)) {\n        // Store the extracted clone once; later occurrences can directly return a $ref.\n        section.set(meta.name, cloned)\n      }\n\n      return createRefObject(meta)\n    }\n\n    // Non-circular object: track traversal path to handle cycles that are intentionally\n    // not extracted (for container maps where we lift refs to legal targets).\n    if (visited.has(obj)) {\n      return undefined\n    }\n\n    const cloned = cloneNodeWithVisitTracking(obj, visited, context)\n\n    // This object may become referenceable while cloning children (e.g. lifting\n    // a container self-cycle to the parent object). If so, extract it now.\n    const lateMeta = circularMeta.get(obj)\n    if (lateMeta === undefined || existingComponentNames.has(obj)) {\n      // Existing components keep their inline structure, but still have back-refs normalized.\n      return cloned\n    }\n\n    const section = getOrCreateExtractedSection(lateMeta.type)\n    if (!section.has(lateMeta.name)) {\n      section.set(lateMeta.name, cloned)\n    }\n\n    return createRefObject(lateMeta)\n  }\n\n  /**\n   * Clones an array, recursively processing each element.\n   */\n  const cloneArray = (arr: unknown[], visited: Set<object>, context: ComponentType): unknown[] => {\n    const result: unknown[] = []\n    for (const item of arr) {\n      const clonedItem = cloneWithRefs(item, visited, context)\n      if (clonedItem !== undefined) {\n        result.push(clonedItem)\n      }\n    }\n    return result\n  }\n\n  /**\n   * Clones an object, recursively processing each property.\n   * Updates context based on property keys.\n   */\n  const cloneObject = (obj: object, visited: Set<object>, context: ComponentType): Record<string, unknown> => {\n    const record = obj as Record<string, unknown>\n    const result: Record<string, unknown> = {}\n\n    for (const key of Object.keys(record)) {\n      const newContext = getContextForKey(key) ?? context\n      const value = record[key]\n      const clonedValue = cloneWithRefs(value, visited, newContext)\n      if (clonedValue !== undefined) {\n        result[key] = clonedValue\n        continue\n      }\n\n      // If a value loops back to its parent container map, lift to a legal reference target.\n      if (value === obj && nonReferenceContainers.has(obj)) {\n        const liftedRef = createLiftedRefForContainer(obj, result)\n        if (liftedRef !== undefined) {\n          result[key] = liftedRef\n        }\n      }\n    }\n\n    return result\n  }\n\n  // Execute Pre-scan: map existing components\n  scanExistingComponents(document)\n\n  // Execute Phase 1: identify all circular objects\n  identifyCircularObjects(document, new Set(), 'schemas')\n\n  // Execute Phase 2: clone with refs\n  const result = cloneWithRefs(document, new Set(), 'schemas') as Record<string, unknown>\n\n  // Inject extracted components into the result document\n  if (extractedComponents.size > 0) {\n    const components = (result.components ?? {}) as Record<string, unknown>\n\n    for (const [componentType, items] of extractedComponents) {\n      const section = (components[componentType] ?? {}) as Record<string, unknown>\n      for (const [name, component] of items) {\n        section[name] = component\n      }\n      components[componentType] = section\n    }\n\n    result.components = components\n  }\n\n  return result\n}\n"],
  "mappings": "AAIA,MAAM,qBAAqB;AAAA,EACzB,SAAS;AAAA,EACT,WAAW;AAAA,EACX,YAAY;AAAA,EACZ,UAAU;AAAA,EACV,eAAe;AAAA,EACf,SAAS;AAAA,EACT,iBAAiB;AAAA,EACjB,OAAO;AAAA,EACP,WAAW;AAAA,EACX,WAAW;AACb;AAGA,MAAM,kBAAkB,OAAO,KAAK,kBAAkB;AAMtD,MAAM,iBAA0D;AAAA,EAC9D,WAAW;AAAA,EACX,YAAY;AAAA,EACZ,aAAa;AAAA,EACb,SAAS;AAAA,EACT,UAAU;AAAA,EACV,OAAO;AAAA,EACP,WAAW;AAAA,EACX,iBAAiB;AAAA,EACjB,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,sBAAsB;AAAA,EACtB,OAAO;AAAA,EACP,OAAO;AAAA,EACP,OAAO;AAAA,EACP,KAAK;AAAA,EACL,YAAY;AAAA,EACZ,mBAAmB;AAAA,EACnB,KAAK;AAAA,EACL,KAAK;AAAA,EACL,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,MAAM;AAAA,EACN,OAAO;AAAA,EACP,OAAO;AACT;AAMA,MAAM,+BAA+B,oBAAI,IAAI,CAAC,cAAc,qBAAqB,WAAW,CAAC;AAM7F,MAAM,mBAAmB,CAAC,QAAsC;AAE9D,QAAM,UAAU,eAAe,GAAG;AAClC,MAAI,YAAY,QAAW;AACzB,WAAO;AAAA,EACT;AAGA,MAAI,IAAI,SAAS,IAAI,KAAK,IAAI,WAAW,CAAC,MAAM,IAAc;AAC5D,WAAO;AAAA,EACT;AAGA,SAAO;AACT;AAmCO,MAAM,iBAAiB,CAC5B,UACA,aAAsC,CAAC,MACX;AAQ5B,QAAM,eAAe,oBAAI,IAA0B;AACnD,QAAM,gBAAgB,oBAAI,IAA2B;AACrD,QAAM,yBAAyB,oBAAI,IAAmD;AACtF,QAAM,yBAAyB,oBAAI,QAAgB;AACnD,QAAM,4BAA4B,oBAAI,QAA2C;AACjF,QAAM,WAA0C;AAAA,IAC9C,SAAS;AAAA,IACT,WAAW;AAAA,IACX,YAAY;AAAA,IACZ,UAAU;AAAA,IACV,eAAe;AAAA,IACf,SAAS;AAAA,IACT,iBAAiB;AAAA,IACjB,OAAO;AAAA,IACP,WAAW;AAAA,IACX,WAAW;AAAA,EACb;AAMA,QAAM,yBAAyB,CAAC,QAAuC;AACrE,UAAM,aAAa,IAAI;AACvB,QAAI,CAAC,YAAY;AACf;AAAA,IACF;AAEA,eAAW,iBAAiB,iBAAiB;AAC3C,YAAM,UAAU,WAAW,aAAa;AACxC,UAAI,CAAC,SAAS;AACZ;AAAA,MACF;AAEA,iBAAW,CAAC,MAAM,KAAK,KAAK,OAAO,QAAQ,OAAO,GAAG;AACnD,YAAI,UAAU,QAAQ,OAAO,UAAU,UAAU;AAC/C,iCAAuB,IAAI,OAAiB,EAAE,MAAM,eAAe,KAAK,CAAC;AAAA,QAC3E;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAaA,QAAM,0BAA0B,CAAC,OAAgB,WAAwB,YAAiC;AAExG,QAAI,UAAU,QAAQ,OAAO,UAAU,UAAU;AAC/C;AAAA,IACF;AAEA,UAAM,MAAM;AAGZ,QAAI,UAAU,IAAI,GAAG,GAAG;AAEtB,UAAI,uBAAuB,IAAI,GAAG,GAAG;AACnC;AAAA,MACF;AAGA,UAAI,CAAC,aAAa,IAAI,GAAG,GAAG;AAC1B,cAAM,WAAW,uBAAuB,IAAI,GAAG;AAC/C,YAAI,UAAU;AAEZ,uBAAa,IAAI,KAAK,QAAQ;AAAA,QAChC,OAAO;AAEL,gBAAM,gBAAgB,cAAc,IAAI,GAAG,KAAK;AAChD,gBAAM,QAAQ,EAAE,SAAS,aAAa;AACtC,uBAAa,IAAI,KAAK;AAAA,YACpB,MAAM;AAAA,YACN,MAAM,GAAG,mBAAmB,aAAa,CAAC,GAAG,KAAK;AAAA,UACpD,CAAC;AAAA,QACH;AAAA,MACF;AACA;AAAA,IACF;AAGA,QAAI,CAAC,cAAc,IAAI,GAAG,GAAG;AAC3B,oBAAc,IAAI,KAAK,OAAO;AAAA,IAChC;AAGA,cAAU,IAAI,GAAG;AAEjB,QAAI,MAAM,QAAQ,GAAG,GAAG;AACtB,iBAAW,QAAQ,KAAK;AACtB,gCAAwB,MAAM,WAAW,OAAO;AAAA,MAClD;AAAA,IACF,OAAO;AAEL,YAAM,SAAS;AACf,iBAAW,OAAO,OAAO,KAAK,MAAM,GAAG;AACrC,cAAM,QAAQ,OAAO,GAAG;AACxB,YACE,6BAA6B,IAAI,GAAG,KACpC,UAAU,QACV,OAAO,UAAU,YACjB,CAAC,MAAM,QAAQ,KAAK,GACpB;AACA,iCAAuB,IAAI,KAAe;AAC1C,oCAA0B,IAAI,OAAiB;AAAA,YAC7C;AAAA,YACA,OAAO;AAAA,UACT,CAAC;AAAA,QACH;AAEA,cAAM,aAAa,iBAAiB,GAAG,KAAK;AAC5C,gCAAwB,OAAO,WAAW,UAAU;AAAA,MACtD;AAAA,IACF;AAGA,cAAU,OAAO,GAAG;AAAA,EACtB;AAGA,QAAM,sBAAsB,oBAAI,IAAyC;AAGzE,QAAM,gBAAgB,OAAO,KAAK,UAAU,EAAE,SAAS;AAGvD,QAAM,kBAAkB,CAAC,SAAgD;AACvE,UAAM,MAAM,EAAE,MAAM,gBAAgB,KAAK,IAAI,IAAI,KAAK,IAAI,GAAG;AAC7D,WAAO,gBAAgB,EAAE,GAAG,KAAK,GAAG,WAAW,IAAI;AAAA,EACrD;AAGA,QAAM,8BAA8B,CAAC,SAA8C;AACjF,UAAM,WAAW,oBAAoB,IAAI,IAAI;AAC7C,QAAI,aAAa,QAAW;AAC1B,aAAO;AAAA,IACT;AAEA,UAAM,UAAU,oBAAI,IAAqB;AACzC,wBAAoB,IAAI,MAAM,OAAO;AACrC,WAAO;AAAA,EACT;AAGA,QAAM,aAAa,CAAC,KAAa,iBAA8C;AAC7E,UAAM,eAAe,aAAa,IAAI,GAAG;AACzC,QAAI,iBAAiB,QAAW;AAC9B,aAAO;AAAA,IACT;AAEA,UAAM,eAAe,uBAAuB,IAAI,GAAG;AACnD,QAAI,iBAAiB,QAAW;AAC9B,mBAAa,IAAI,KAAK,YAAY;AAClC,aAAO;AAAA,IACT;AAEA,UAAM,QAAQ,EAAE,SAAS,YAAY;AACrC,UAAM,OAAqB;AAAA,MACzB,MAAM;AAAA,MACN,MAAM,GAAG,mBAAmB,YAAY,CAAC,GAAG,KAAK;AAAA,IACnD;AACA,iBAAa,IAAI,KAAK,IAAI;AAC1B,WAAO;AAAA,EACT;AAGA,QAAM,8BAA8B,CAClC,WACA,oBACwC;AACxC,UAAM,OAAO,0BAA0B,IAAI,SAAS;AACpD,QAAI,SAAS,QAAW;AACtB,aAAO;AAAA,IACT;AAEA,QAAI,KAAK,QAAQ,gBAAgB,KAAK,QAAQ,qBAAqB;AACjE,YAAM,OAAO,WAAW,KAAK,OAAO,SAAS;AAC7C,aAAO,gBAAgB,IAAI;AAAA,IAC7B;AAIA,UAAM,YAAY;AAClB,eAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,SAAS,GAAG;AACpD,UAAI,UAAU,QAAQ,OAAO,UAAU,YAAY,UAAU,WAAW;AACtE;AAAA,MACF;AAEA,YAAM,iBAAiB;AACvB,YAAM,OAAO,WAAW,gBAAgB,WAAW;AACnD,UAAI,CAAC,uBAAuB,IAAI,cAAc,GAAG;AAC/C,cAAM,UAAU,4BAA4B,KAAK,IAAI;AACrD,YAAI,CAAC,QAAQ,IAAI,KAAK,IAAI,GAAG;AAC3B,gBAAM,cAAc,kBAAkB,GAAG;AACzC,cAAI,gBAAgB,QAAW;AAC7B,oBAAQ,IAAI,KAAK,MAAM,WAAW;AAAA,UACpC;AAAA,QACF;AAAA,MACF;AAEA,aAAO,gBAAgB,IAAI;AAAA,IAC7B;AAEA,WAAO;AAAA,EACT;AAEA,QAAM,YAAY,CAAC,KAAa,SAAsB,YAAoC;AACxF,WAAO,MAAM,QAAQ,GAAG,IAAI,WAAW,KAAK,SAAS,OAAO,IAAI,YAAY,KAAK,SAAS,OAAO;AAAA,EACnG;AAEA,QAAM,6BAA6B,CAAC,KAAa,SAAsB,YAAoC;AAEzG,YAAQ,IAAI,GAAG;AACf,UAAM,SAAS,UAAU,KAAK,SAAS,OAAO;AAC9C,YAAQ,OAAO,GAAG;AAClB,WAAO;AAAA,EACT;AAOA,QAAM,gBAAgB,CAAC,OAAgB,SAAsB,YAAoC;AAC/F,QAAI,UAAU,QAAQ,OAAO,UAAU,UAAU;AAC/C,aAAO;AAAA,IACT;AAEA,UAAM,MAAM;AACZ,UAAM,OAAO,aAAa,IAAI,GAAG;AAGjC,QAAI,SAAS,QAAW;AACtB,UAAI,QAAQ,IAAI,GAAG,GAAG;AACpB,eAAO,gBAAgB,IAAI;AAAA,MAC7B;AAEA,YAAMA,UAAS,2BAA2B,KAAK,SAAS,OAAO;AAC/D,UAAI,uBAAuB,IAAI,GAAG,GAAG;AAGnC,eAAOA;AAAA,MACT;AAEA,YAAMC,WAAU,4BAA4B,KAAK,IAAI;AACrD,UAAI,CAACA,SAAQ,IAAI,KAAK,IAAI,GAAG;AAE3B,QAAAA,SAAQ,IAAI,KAAK,MAAMD,OAAM;AAAA,MAC/B;AAEA,aAAO,gBAAgB,IAAI;AAAA,IAC7B;AAIA,QAAI,QAAQ,IAAI,GAAG,GAAG;AACpB,aAAO;AAAA,IACT;AAEA,UAAM,SAAS,2BAA2B,KAAK,SAAS,OAAO;AAI/D,UAAM,WAAW,aAAa,IAAI,GAAG;AACrC,QAAI,aAAa,UAAa,uBAAuB,IAAI,GAAG,GAAG;AAE7D,aAAO;AAAA,IACT;AAEA,UAAM,UAAU,4BAA4B,SAAS,IAAI;AACzD,QAAI,CAAC,QAAQ,IAAI,SAAS,IAAI,GAAG;AAC/B,cAAQ,IAAI,SAAS,MAAM,MAAM;AAAA,IACnC;AAEA,WAAO,gBAAgB,QAAQ;AAAA,EACjC;AAKA,QAAM,aAAa,CAAC,KAAgB,SAAsB,YAAsC;AAC9F,UAAME,UAAoB,CAAC;AAC3B,eAAW,QAAQ,KAAK;AACtB,YAAM,aAAa,cAAc,MAAM,SAAS,OAAO;AACvD,UAAI,eAAe,QAAW;AAC5B,QAAAA,QAAO,KAAK,UAAU;AAAA,MACxB;AAAA,IACF;AACA,WAAOA;AAAA,EACT;AAMA,QAAM,cAAc,CAAC,KAAa,SAAsB,YAAoD;AAC1G,UAAM,SAAS;AACf,UAAMA,UAAkC,CAAC;AAEzC,eAAW,OAAO,OAAO,KAAK,MAAM,GAAG;AACrC,YAAM,aAAa,iBAAiB,GAAG,KAAK;AAC5C,YAAM,QAAQ,OAAO,GAAG;AACxB,YAAM,cAAc,cAAc,OAAO,SAAS,UAAU;AAC5D,UAAI,gBAAgB,QAAW;AAC7B,QAAAA,QAAO,GAAG,IAAI;AACd;AAAA,MACF;AAGA,UAAI,UAAU,OAAO,uBAAuB,IAAI,GAAG,GAAG;AACpD,cAAM,YAAY,4BAA4B,KAAKA,OAAM;AACzD,YAAI,cAAc,QAAW;AAC3B,UAAAA,QAAO,GAAG,IAAI;AAAA,QAChB;AAAA,MACF;AAAA,IACF;AAEA,WAAOA;AAAA,EACT;AAGA,yBAAuB,QAAQ;AAG/B,0BAAwB,UAAU,oBAAI,IAAI,GAAG,SAAS;AAGtD,QAAM,SAAS,cAAc,UAAU,oBAAI,IAAI,GAAG,SAAS;AAG3D,MAAI,oBAAoB,OAAO,GAAG;AAChC,UAAM,aAAc,OAAO,cAAc,CAAC;AAE1C,eAAW,CAAC,eAAe,KAAK,KAAK,qBAAqB;AACxD,YAAM,UAAW,WAAW,aAAa,KAAK,CAAC;AAC/C,iBAAW,CAAC,MAAM,SAAS,KAAK,OAAO;AACrC,gBAAQ,IAAI,IAAI;AAAA,MAClB;AACA,iBAAW,aAAa,IAAI;AAAA,IAC9B;AAEA,WAAO,aAAa;AAAA,EACtB;AAEA,SAAO;AACT;",
  "names": ["cloned", "section", "result"]
}
