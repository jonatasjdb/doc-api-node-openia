const COMPONENT_PREFIXES = {
  schemas: "CircularSchema",
  responses: "CircularResponse",
  parameters: "CircularParameter",
  examples: "CircularExample",
  requestBodies: "CircularRequestBody",
  headers: "CircularHeader",
  securitySchemes: "CircularSecurityScheme",
  links: "CircularLink",
  callbacks: "CircularCallback",
  pathItems: "CircularPathItem"
};
const COMPONENT_TYPES = Object.keys(COMPONENT_PREFIXES);
const KEY_TO_CONTEXT = {
  responses: "responses",
  parameters: "parameters",
  requestBody: "requestBodies",
  headers: "headers",
  examples: "examples",
  links: "links",
  callbacks: "callbacks",
  securitySchemes: "securitySchemes",
  schema: "schemas",
  items: "schemas",
  additionalProperties: "schemas",
  allOf: "schemas",
  oneOf: "schemas",
  anyOf: "schemas",
  not: "schemas",
  properties: "schemas",
  patternProperties: "schemas",
  get: "pathItems",
  put: "pathItems",
  post: "pathItems",
  delete: "pathItems",
  options: "pathItems",
  head: "pathItems",
  patch: "pathItems",
  trace: "pathItems"
};
const NON_REFERENCE_CONTAINER_KEYS = /* @__PURE__ */ new Set(["properties", "patternProperties", "responses"]);
const getContextForKey = (key) => {
  const context = KEY_TO_CONTEXT[key];
  if (context !== void 0) {
    return context;
  }
  if (key.includes("{$") || key.charCodeAt(0) === 47) {
    return "pathItems";
  }
  return null;
};
const circularToRefs = (document, extraProps = {}) => {
  const circularMeta = /* @__PURE__ */ new Map();
  const objectContext = /* @__PURE__ */ new Map();
  const existingComponentNames = /* @__PURE__ */ new Map();
  const nonReferenceContainers = /* @__PURE__ */ new WeakSet();
  const nonReferenceContainerInfo = /* @__PURE__ */ new WeakMap();
  const counters = {
    schemas: 0,
    responses: 0,
    parameters: 0,
    examples: 0,
    requestBodies: 0,
    headers: 0,
    securitySchemes: 0,
    links: 0,
    callbacks: 0,
    pathItems: 0
  };
  const scanExistingComponents = (doc) => {
    const components = doc.components;
    if (!components) {
      return;
    }
    for (const componentType of COMPONENT_TYPES) {
      const section = components[componentType];
      if (!section) {
        continue;
      }
      for (const [name, value] of Object.entries(section)) {
        if (value !== null && typeof value === "object") {
          existingComponentNames.set(value, { type: componentType, name });
        }
      }
    }
  };
  const identifyCircularObjects = (value, ancestors, context) => {
    if (value === null || typeof value !== "object") {
      return;
    }
    const obj = value;
    if (ancestors.has(obj)) {
      if (nonReferenceContainers.has(obj)) {
        return;
      }
      if (!circularMeta.has(obj)) {
        const existing = existingComponentNames.get(obj);
        if (existing) {
          circularMeta.set(obj, existing);
        } else {
          const componentType = objectContext.get(obj) ?? context;
          const count = ++counters[componentType];
          circularMeta.set(obj, {
            type: componentType,
            name: `${COMPONENT_PREFIXES[componentType]}${count}`
          });
        }
      }
      return;
    }
    if (!objectContext.has(obj)) {
      objectContext.set(obj, context);
    }
    ancestors.add(obj);
    if (Array.isArray(obj)) {
      for (const item of obj) {
        identifyCircularObjects(item, ancestors, context);
      }
    } else {
      const record = obj;
      for (const key of Object.keys(record)) {
        const child = record[key];
        if (NON_REFERENCE_CONTAINER_KEYS.has(key) && child !== null && typeof child === "object" && !Array.isArray(child)) {
          nonReferenceContainers.add(child);
          nonReferenceContainerInfo.set(child, {
            key,
            owner: obj
          });
        }
        const newContext = getContextForKey(key) ?? context;
        identifyCircularObjects(child, ancestors, newContext);
      }
    }
    ancestors.delete(obj);
  };
  const extractedComponents = /* @__PURE__ */ new Map();
  const hasExtraProps = Object.keys(extraProps).length > 0;
  const createRefObject = (meta) => {
    const ref = { $ref: `#/components/${meta.type}/${meta.name}` };
    return hasExtraProps ? { ...ref, ...extraProps } : ref;
  };
  const getOrCreateExtractedSection = (type) => {
    const existing = extractedComponents.get(type);
    if (existing !== void 0) {
      return existing;
    }
    const section = /* @__PURE__ */ new Map();
    extractedComponents.set(type, section);
    return section;
  };
  const ensureMeta = (obj, fallbackType) => {
    const existingMeta = circularMeta.get(obj);
    if (existingMeta !== void 0) {
      return existingMeta;
    }
    const existingName = existingComponentNames.get(obj);
    if (existingName !== void 0) {
      circularMeta.set(obj, existingName);
      return existingName;
    }
    const count = ++counters[fallbackType];
    const meta = {
      type: fallbackType,
      name: `${COMPONENT_PREFIXES[fallbackType]}${count}`
    };
    circularMeta.set(obj, meta);
    return meta;
  };
  const createLiftedRefForContainer = (container, clonedContainer) => {
    const info = nonReferenceContainerInfo.get(container);
    if (info === void 0) {
      return void 0;
    }
    if (info.key === "properties" || info.key === "patternProperties") {
      const meta = ensureMeta(info.owner, "schemas");
      return createRefObject(meta);
    }
    const responses = container;
    for (const [key, value] of Object.entries(responses)) {
      if (value === null || typeof value !== "object" || value === container) {
        continue;
      }
      const responseObject = value;
      const meta = ensureMeta(responseObject, "responses");
      if (!existingComponentNames.has(responseObject)) {
        const section = getOrCreateExtractedSection(meta.type);
        if (!section.has(meta.name)) {
          const clonedValue = clonedContainer?.[key];
          if (clonedValue !== void 0) {
            section.set(meta.name, clonedValue);
          }
        }
      }
      return createRefObject(meta);
    }
    return void 0;
  };
  const cloneNode = (obj, visited, context) => {
    return Array.isArray(obj) ? cloneArray(obj, visited, context) : cloneObject(obj, visited, context);
  };
  const cloneNodeWithVisitTracking = (obj, visited, context) => {
    visited.add(obj);
    const cloned = cloneNode(obj, visited, context);
    visited.delete(obj);
    return cloned;
  };
  const cloneWithRefs = (value, visited, context) => {
    if (value === null || typeof value !== "object") {
      return value;
    }
    const obj = value;
    const meta = circularMeta.get(obj);
    if (meta !== void 0) {
      if (visited.has(obj)) {
        return createRefObject(meta);
      }
      const cloned2 = cloneNodeWithVisitTracking(obj, visited, context);
      if (existingComponentNames.has(obj)) {
        return cloned2;
      }
      const section2 = getOrCreateExtractedSection(meta.type);
      if (!section2.has(meta.name)) {
        section2.set(meta.name, cloned2);
      }
      return createRefObject(meta);
    }
    if (visited.has(obj)) {
      return void 0;
    }
    const cloned = cloneNodeWithVisitTracking(obj, visited, context);
    const lateMeta = circularMeta.get(obj);
    if (lateMeta === void 0 || existingComponentNames.has(obj)) {
      return cloned;
    }
    const section = getOrCreateExtractedSection(lateMeta.type);
    if (!section.has(lateMeta.name)) {
      section.set(lateMeta.name, cloned);
    }
    return createRefObject(lateMeta);
  };
  const cloneArray = (arr, visited, context) => {
    const result2 = [];
    for (const item of arr) {
      const clonedItem = cloneWithRefs(item, visited, context);
      if (clonedItem !== void 0) {
        result2.push(clonedItem);
      }
    }
    return result2;
  };
  const cloneObject = (obj, visited, context) => {
    const record = obj;
    const result2 = {};
    for (const key of Object.keys(record)) {
      const newContext = getContextForKey(key) ?? context;
      const value = record[key];
      const clonedValue = cloneWithRefs(value, visited, newContext);
      if (clonedValue !== void 0) {
        result2[key] = clonedValue;
        continue;
      }
      if (value === obj && nonReferenceContainers.has(obj)) {
        const liftedRef = createLiftedRefForContainer(obj, result2);
        if (liftedRef !== void 0) {
          result2[key] = liftedRef;
        }
      }
    }
    return result2;
  };
  scanExistingComponents(document);
  identifyCircularObjects(document, /* @__PURE__ */ new Set(), "schemas");
  const result = cloneWithRefs(document, /* @__PURE__ */ new Set(), "schemas");
  if (extractedComponents.size > 0) {
    const components = result.components ?? {};
    for (const [componentType, items] of extractedComponents) {
      const section = components[componentType] ?? {};
      for (const [name, component] of items) {
        section[name] = component;
      }
      components[componentType] = section;
    }
    result.components = components;
  }
  return result;
};
export {
  circularToRefs
};
//# sourceMappingURL=circular-to-refs.js.map
